{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-01-05T01:14:47.525107+00:00",
  "repo": "core-wg/attacks-on-coap",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "close?",
      "description": "",
      "color": "fef2c0"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOHUICes5JdiZn",
      "title": "Comments received during WG adoption call - freshness and recentness",
      "url": "https://github.com/core-wg/attacks-on-coap/issues/1",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "MEMBER",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "close?"
      ],
      "body": "**Henk Birkholz**\r\nhttps://mailarchive.ietf.org/arch/msg/core/ULPpd1BBiouRlS9qJKHmVbcbslo/\r\n\r\nI think you are confusing freshness and recentness, fundamentally.\r\n\r\nFreshness is not connected to recentness, but they are similar - and\r\nthat is the tricky part. Something can be fresh after a huge amount of\r\ntime according to a time-scale (not recent). Something can be stale\r\nafter a tiny amount of time according to a time-scale (recent).\r\nFreshness is a quality of an assertion that expresses that the assertion\r\nstill reflects the state of its subject, at the time of checking it.\r\nFreshness can be very tricky to check. Is that what you want? Probably\r\nnot. My assumption is what you would want is a response with appropriate\r\nrecentness (at least that is how I read your text).",
      "createdAt": "2022-05-11T11:32:12Z",
      "updatedAt": "2022-12-23T05:48:29Z",
      "closedAt": "2022-12-23T05:48:29Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": ".",
          "createdAt": "2022-05-11T11:32:57Z",
          "updatedAt": "2022-05-11T11:35:19Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": "I don't think neither `freshness` or `recentness` are well defined terms when it comes to security and protocols. The term and the definition might not be perfect but should likely just align with RFC 9175. The CORE WG decided to use the term freshness in RFC 9175, this is a just a companion document to RFC 9175.\r\n\r\nI will check that the text aligns with RFC 9175 and also add a reference to RFC 9175 regarding the definition.\r\n\r\n",
          "createdAt": "2022-11-09T15:06:44Z",
          "updatedAt": "2022-11-09T15:06:44Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOHUICes5JdjdN",
      "title": "Comments received during WG adoption call - RFC 7959",
      "url": "https://github.com/core-wg/attacks-on-coap/issues/2",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "MEMBER",
      "assignees": [
        "chrysn",
        "gselander"
      ],
      "labels": [],
      "body": "**Mohamed Boucadair**\r\nhttps://mailarchive.ietf.org/arch/msg/core/4czSZYmRgMVgRA2d8mVpGUBwD0w/\r\n\r\nIt would helpful to explicit in Section 2.1 that this is about 7959, not the new block (to-be-RFC9177). Assessing the case of the new-block would be useful as well. ",
      "createdAt": "2022-05-11T11:35:59Z",
      "updatedAt": "2022-12-23T06:03:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": "How does the attacks in draft-ietf-core-attacks-on-coap and the mitigations (Request-tag and ETag processing) defined in RFC 9175 apply to the Q-Block1 and Q-Block2 Options defined in 9177?",
          "createdAt": "2022-11-09T16:05:40Z",
          "updatedAt": "2022-11-09T16:05:40Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": "@chrysn can you make an update describing how the attacks applies or do not applies to Q-Block1 and Q-Block2 Options defined in 9177?",
          "createdAt": "2022-11-09T18:00:01Z",
          "updatedAt": "2022-11-09T18:00:01Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOHUICes5JdkLq",
      "title": "Comments received during WG adoption call - Jon Shallow",
      "url": "https://github.com/core-wg/attacks-on-coap/issues/3",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "MEMBER",
      "assignees": [
        "chrysn",
        "gselander"
      ],
      "labels": [],
      "body": "**Jon Swallow**\r\nhttps://mailarchive.ietf.org/arch/msg/core/GNnRO4-iE_jRb5X2HfRtV3c8Sew/\r\n\r\nMed is actually referring to 2.4, but this made me realize there was a trap of seeing Block and hence thinking RFC7959 for 2.1 - \"The Block Attack\" which actually has no reference to CoAP blocks.  A better section title could be \"The Blocking Attack\" and s/Block Attack/Blocking Attack/ elsewhere.\r\n\r\nFor 2.4, \"Fragment\" in terms of CoAP blocks is not defined, and is not used in RFC7959 (RFC7959 refers to fragmentation issues outside of the CoAP layer), so is unclear that \"fragment\" is meant to be referring to a CoAP RFC7959 (or draft-ietf-core-new-block to-be-RFC9177) block.  \r\n\r\nThus, \"2.4. The Request CoAP Block Rearrangement Attack\" is a step in the right direction for me.  Then most of the usage of the word fragment needs to be replaced with block.\r\n\r\nAs a note for mitigating 2.4.1, to-be-RFC9177 requires the use of Request-Tag (https://datatracker.ietf.org/doc/html/draft-ietf-core-new-block#section-4.3) and good use of tokens (https://datatracker.ietf.org/doc/html/draft-ietf-core-new-block#section-6). \r\n\r\nThe lost blocks recovery mechanisms in to-be-RFC9177 mitigate the risk of the wrong block being processed in a request by the server.\r\n\r\nAgain using Block-Wise transfers, there has not been consideration for a delay attack causing the server to send back the wrong data in a BLOCK2 response.  See https://github.com/core-wg/echo-request-tag/issues/77 .  If the attacker delays the first request (which triggers a BLOCK2 response), and then sends it just before/after the second request (also triggering a BLOCK2 response), the request for the next block for, say the second request, from the client may get back the block from either the first or second request.  This can only be mitigated using the Request-Tag on each request, even though BLOCK1 is not being used for the request.  I think this attack also needs to be included.\r\n",
      "createdAt": "2022-05-11T11:38:35Z",
      "updatedAt": "2022-12-23T06:03:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": "https://mailarchive.ietf.org/arch/msg/core/dvPyvSLnQKpeaRUR3AW5h2tn6yQ/\r\n\r\nHi Jon,\r\n\r\nI'm not sure about:\r\n\r\n > Again using Block-Wise transfers, there has not been consideration\r\nfor a delay attack causing the server to send back the wrong data in a\r\nBLOCK2 response.  See\r\nhttps://github.com/core-wg/echo-request-tag/issues/77 .  If the attacker\r\ndelays the first request (which triggers a BLOCK2 response), and then\r\nsends it just before/after the second request (also triggering a BLOCK2\r\nresponse), the request for the next block for, say the second request,\r\nfrom the client may get back the block from either the first or second\r\nrequest.  This can only be mitigated using the Request-Tag on each\r\nrequest, even though BLOCK1 is not being used for the request.  I think\r\nthis attack also needs to be included.\r\n\r\nDoes this refer to RFC7959?\r\n\r\n > may get back the block from either the first or second request.\r\n\r\nBut the response will contain a token, which is used for\r\nrequest-response matching. So, do you assume, that both request are\r\nusing the same token (maybe then more a unintended violation of the\r\ntoken uniqness)?\r\n\r\nbest regards\r\nAchim",
          "createdAt": "2022-05-11T11:40:18Z",
          "updatedAt": "2022-05-11T11:40:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": "https://mailarchive.ietf.org/arch/msg/core/tuI9NNtx5t3NDsK0zfhdvNGCmEg/\r\n\r\nHi Achim,\r\n\r\ndraft-mattsson-core-coap-attacks has a focus on using Request-Tag to mitigate attacks.  Usage of ETag is not mandated in RFC7252 or RFC7959 as far as I can tell (but is in to-be-RFC9177), but using ETag with Block2 mitigates potential attack confusion. See attack below.\r\n\r\nOtherwise, please see inline.\r\n\r\nRegards\r\n\r\nJon\r\n\r\n> -----Original Message-----\r\n> From: Achim Kraus [mailto: [achimkraus@gmx.net](mailto:achimkraus@gmx.net)]\r\n> Sent: 25 February 2022 16:22\r\n> To: [jon@jpshallow.com](mailto:jon@jpshallow.com)\r\n> Cc: [mohamed.boucadair@orange.com](mailto:mohamed.boucadair@orange.com); 'Marco Tiloca'; [core@ietf.org](mailto:core@ietf.org)\r\n> Subject: Re: [core] WG Adoption Call for draft-mattsson-core-coap-attacks\r\n> \r\n> Hi Jon,\r\n> \r\n> I'm not sure about:\r\n> \r\n>  > Again using Block-Wise transfers, there has not been consideration\r\n> for a delay attack causing the server to send back the wrong data in a\r\n> BLOCK2 response.  See\r\n> https://github.com/core-wg/echo-request-tag/issues/77 .  If the attacker\r\n> delays the first request (which triggers a BLOCK2 response), and then\r\n> sends it just before/after the second request (also triggering a BLOCK2\r\n> response), the request for the next block for, say the second request,\r\n> from the client may get back the block from either the first or second\r\n> request.  This can only be mitigated using the Request-Tag on each\r\n> request, even though BLOCK1 is not being used for the request.  I think\r\n> this attack also needs to be included.\r\n> \r\n> Does this refer to RFC7959?\r\n\r\nJon> Yes, as Block2s are being used as well as RFC9175\r\n> \r\n>  > may get back the block from either the first or second request.\r\n> \r\n> But the response will contain a token, which is used for\r\n> request-response matching. So, do you assume, that both request are\r\n> using the same token (maybe then more a unintended violation of the\r\n> token uniqness)?\r\n\r\nJon> No.  I would be expecting the Token to be different in each request that asks for the next payload of the body.  Use of the same Token is not recommended as per RFC9175, but people do not realize that an empty token should not be used across multiple requests (another attack if \"Foe\" was removing tokens as the CoAP packets passed through...).\r\n\r\nJon> Client gets earlier value (ETag not used) against what it thought was the second request.\r\n\r\n```\r\n   Client   Foe   Server\r\n      |      |      |\r\n      +------X      |    POST \"request\" T:1 { \"offset\":0, \"length\":2000}\r\n      |      |      |\r\n      +------------->    POST \"request\" T:2 { \"offset\":4000, \"length\":2000}\r\n      |      |      |\r\n      |      @------>    POST \"request\" T:1 { \"offset\":0, \"length\":2000}\r\n      |      |      |\r\n      <-------------+    2.04 T:2 Block2:0/1/1024 { data containing 4000:1024 }\r\n      |      |      |\r\n      <-------------+    2.04 T:1 Block2:0/1/1024 { data containing 0:1024 }\r\n      |      |      |\r\n      +------------->    POST \"request\" T:3 Block2:0/_/1024\r\n                         server - is this continuation of request using T:1 or T:2 ?\r\n      |      |      |\r\n      <-------------+    2.04 T:3 Block2:1/_/1024 { data containing 1024:2000 }\r\n                         Was this the expected data ?\r\n      |      |      |\r\n\r\n```\r\nThis is fixed if Request differentiating ETag is used in the response. The client may not be able to get the missing secondary block from the alternative request, unless Request-Tag is used in the initial request (hence issue 77).\r\n\r\n~Jon>",
          "createdAt": "2022-05-11T11:41:24Z",
          "updatedAt": "2022-05-11T11:41:55Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "MEMBER",
          "body": "I changed \"block attack\" to \"blocking attack\", thanks for the suggestion.\r\n\r\nRight or wrong, the term \"fragment\" is used heavily in RFC 9175 which this is an companion document to. RFC 9175 cannot be changes now. Even if the term is not perfect it might be better for draft-ietf-core-attacks-on-coap to align with RFC 9175.\r\n\r\n@chrysn ?",
          "createdAt": "2022-11-09T18:31:32Z",
          "updatedAt": "2022-11-09T18:31:32Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOHUICes5JdlrB",
      "title": "Comments received during WG adoption call - Section 2.1 The Block Attack",
      "url": "https://github.com/core-wg/attacks-on-coap/issues/4",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "MEMBER",
      "assignees": [
        "emanjon"
      ],
      "labels": [],
      "body": "**Achim Kraus**\r\nhttps://mailarchive.ietf.org/arch/msg/core/_KAqFsWT0-U7AhBTobU-Ar-DZr4/\r\n\r\nI'm not sure, what the purpose of this work would/should be.\r\n\r\nReading\r\n\r\n\"2.  Attacks on CoAP\r\n\r\n2.1.  The Block Attack\r\n\r\n    An on-path attacker can block the delivery of any number of requests\r\n    or responses.  The attack can also be performed by an attacker\r\n    jamming the lower layer radio protocol.\"\r\n\r\nis true for much more protocols, not only CoAP or DTLS. You can even cut\r\nwires. To narrow such a general issues to a statement about a single\r\nprotocol may be a little smelly.\r\n\r\n\"In this document we show that protecting CoAP with a security\r\n    protocol on another layer is not nearly enough to securely control\r\n    actuators (and in many cases sensors) and that secure operation often\r\n    demands far more than the four properties traditionally provided by\r\n    security protocols.\"\r\n\r\nThe document addresses weakness, but it's hard to see, that this\r\nweakness is qualified. Many of the attacks seems to be somehow \"easy for\r\nan on-path-attacker on unecrypted messages\". And, yes could not be\r\nexcluded also for encrypted messages. In my opinion, encryption makes\r\nsuch attacks much harder to apply, less attractive. And so \"not nearly\r\nenough\" seems to be too strong.\r\n\r\nMy impression is, this document puts doubts on using DTLS 1.2.\r\nIt puts threats of unencrypted messages too close to the same (but much\r\nlower) threats using encryption. I would appreciate, if the document is\r\nclearer about that. Not that it turns into a disservice.\r\n",
      "createdAt": "2022-05-11T11:43:48Z",
      "updatedAt": "2022-12-23T06:38:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOHUICes5WDFMN",
      "title": "Availability",
      "url": "https://github.com/core-wg/attacks-on-coap/issues/5",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "MEMBER",
      "assignees": [
        "emanjon"
      ],
      "labels": [],
      "body": "Availability is a required property for secure operation which is a bit different from the other properties of confiedentiality, intergrity, and replay.\r\n\r\nAdded availability to the introduction, should be discussed in the body as well where appropriate.",
      "createdAt": "2022-11-10T10:34:38Z",
      "updatedAt": "2022-12-23T06:02:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOHUICes5Z8Kcl",
      "title": "Comments on Encryption from Achim",
      "url": "https://github.com/core-wg/attacks-on-coap/issues/6",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "MEMBER",
      "assignees": [
        "emanjon"
      ],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/core/BOG6xkClHS29vlQqUYaQBwZkB58/\r\n\r\nI appreciate the added statement about encryption in the abstract.\r\nDoes the\r\n\r\n\"Several of the discussed attacks can be mitigated with the solutions in\r\nRFC 9175.\"\r\n\r\nrequire the combination with encryption in order to mitigate the\r\nattacks? I think so.\r\n\r\nOverall, I'm wondering, if the preconditions of such attacks could be\r\ndocumented clearer?\r\n\r\nE.g. assuming an \"on-path-attacker\" RFC 9175 without encryption may be\r\nin vain.\r\n\r\nA couple of attacks assume, that tokens are reused frequently. In my\r\nexperience, that's not the case (except in cases, where someone stick to\r\n(re-)use the empty token to save bandwidth, or reuse tokens for\r\ntesting/debugging). Different tokens and replay-windows are then\r\ncreating also protection in a couple of cases.\r\n\r\nWith a list of preconditions it would be easier to see,\r\nif a system is affected by that attack or not.\r\n\r\nYou added \"availability\", but I miss the see an example, if there\r\nis a specific risk using coap.",
      "createdAt": "2022-12-23T06:16:14Z",
      "updatedAt": "2022-12-23T06:38:28Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": []
}